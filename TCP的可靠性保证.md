---
typora-copy-images-to: img
---

# IP协议

## 特点

### 1、不可靠

​	不能保证IP数据报能成功到达目的地。

​	IP仅提供最好的传输服务。如果发生某种错误，如某个路由器暂时用完了缓冲区，IP有一个简单的错误处理算法：丢弃该数据报，然后发送ICMP消息报给信源端。

### 2、无连接

​	IP并不维护任何后续数据报的状态信息。每个数据报的处理都是相互独立的。

## IP首部

​	普通的IP首部长20个字节，除非含有选项字段。

![1552141849301](.\img\1552141849301.png)

| 名称     | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| 版本     | 目前版本号是4                                                |
| 首部长度 | 指的是首部占32bit字的数目。因此首部最长为60个字节            |
| 服务类型 | 3bit的优先权子字段（现已经被忽略）<br>4bit的TOS子字段和1bit的未用位但必须置0<br>4bit的TOS分别代表：最小时延，最大吞吐量，最高可靠性，最小费用<br>4bit中只能有置其中1bit。如果4bit均为0，那么意味着是一般服务 |
| 总长度   | 整个IP数据包的长度，以字节为单位                             |
| 标识     | 唯一的标识主机发送的每一份数据报。通常每发一份报文它的值会加一 |
| 标志位   |                                                              |
| 片偏移   |                                                              |
| TTL      | time-to-live:生存时间。设置了数据报可以经过的最多路由器数<br>TTL的值通常由源主机设定，一旦经过一个处理它的路由器，它的值就减去1。当该值为0时，数据报被丢弃，并发送ICMP报文通知源主机 |
| 协议     | 由于TCP、UDP、ICMP和IGMP都要向IP传送消息。用来标识数据来源于上述哪个协议。 <br>1—— ICMP协议<br>2—— IGMP协议<br>6——TCP协议<br>17——UDP协议 |
| 校验和   | 首先把校验和字段设置为0<br>然后对首部中每个16bit进行二进制反码求和，结果存入校验和字段中。<br>当受到一份IP数据报后，同样对首部的每个16bit进行二进制反码求和。由于接收方在计算过程中包含了发送方存在首部中的校验和，因此，如果首部在传输过程中没有发生任何差错，那么接收方计算的结果应该为全1。如果有差错，就丢弃。 |

# TCP协议

## TCP首部

​	TCP首部，通常是20个字节。

![1548325239098](.\img\1548325239098.png)



| 名称                 | 含义                                                         |
| -------------------- | ------------------------------------------------------------ |
| 源端口号和目的端口号 | 用于寻找发端和收端的应用进程；这两个值加上IP首部中的源端IP和目的端IP,唯一确定一个TCP连接 |
| 32位序号             | 标识这个报文段中的第一个数据字节。TCP用序号对每个字节进行计数。序号是32bit 的无符号数，序号到达2^32 -1后又从0开始 |
| 32位确认序号         | 确认序号包含发送确认的一端，所期望收到的下一个序号。<br>因此确认序号应当是上次已成功收到数据字节序号+1 |
| 4位首部长度          | 首部中32 bit的数目；所以，tcp首部最多为15*4=60字节。         |
| 16位窗口大小         | 为字节数；起始于确认序号指明的值，这个值是接收端期望接收的字节数 |
| 16位校验和           |                                                              |
| 16位紧急指针         | 当URG=1时，起作用；和序号值相加，表示紧急数据的最后一个字节的序号 |

| 标志位 | 含义                                 |
| ------ | ------------------------------------ |
| URG    | 紧急指针（有效）                     |
| ACK    | 确认序号有效                         |
| PSH    | 接收方应该尽快将这个报文段交给应用层 |
| RST    | 重建连接                             |
| SYN    | 同步序号，用来发起一个连接           |
| FIN    | 发送端完成发送任务                   |

## TCP连接和终止

### 1、建立连接

```sequence
title:TCP三次握手
客户端->服务端:1、SYN=1;初始序号ISN（c）
服务端->客户端:2、SYN=1;初始序号ISN（s）;ACK=1;INS(c)+1
客户端->服务端:3、ACK=1;ISN(s)+1
```

​	3个报文段完成连接的建立，这个过程称之为三次握手；

​	当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化。

### 2、终止连接

```sequence
title:TCP4次握手
客户端->服务端:FIN(C)=1
服务端->客户端:ACK
服务端->客户端:FIN(S)=1
客户端->服务端:ACK
```

​	TCP连接是全双工连接，因此每个方向必须进行单独的关闭

## 最大报文段长度

​	最大报文段长度(MSS)表示TCP传往另一端的最大数据的长度。当一个连接建立时，连接的双发各自都要通告各自的MSS.

​	如果一方不接受来自另一方的MSS,则默认为536字节。



# 基础知识

​	对于TCP通信来说，每个TCP Socket在内核中都有一个发送缓冲区和接收缓冲区。

​	TCP的全双工的工作模式及TCP的滑动窗口便依赖于这两个独立的Buffer及此Buffer的填充状态。

​	接收缓冲区把数据缓存入内核，若应用进程一直没有调用Socket的read方法进行读取的话，则此数据会一直被缓存在接收缓冲区内。不管进程是否读取Socket，对端发来的数据都会经由内核接收并且缓存到Socket的内核接收缓冲区中。read方法所做的工作就是：把内核接收缓冲区中的数据复制到应用层用户的Buffer中，仅此而已。

​	进程调用Socket的send方法发送数据的时候，最简单的情况(也是一般情况)是将数据从应用层用户的Buffer里复制到Socket的内存发送缓冲区中，然后send便会在上层返回。换句话说，数据不一定会被发送到对端，send仅仅是把应用层的Buffer数据复制到Socket的内核发送Buffer中。

​	对于UDP通信来说，每个UDP Socket都有一个接受缓冲区，而没有发送缓冲区，从概念来说，只有有数据就发送，不管对方是否可以正确接受。



## 滑动窗口和流量控制基础

​	Socket的接收缓冲区被TCP和UDP用来缓存网络上收到的数据，一直保存到应用进程读走为止。

​	对于TCP来说，如果应用进程一直没有读取，则Buffer满了之后，发生的动作是：通知对端的TCP协议中的窗口关闭，保证TCP套接口接收缓冲区不会溢出。保证了TCP是可靠传输的。这个便是滑动窗口的实现。

​	因为对方不允许发出超过通知窗口大小的数据，因此如果对方无视窗口大小而发出了超出窗口大小的数据，则接收方的TCP将其丢弃。这就是TCP的流量控制原理。



​	



























