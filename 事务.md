# 本地事务

## 事务的ACID特性

* 原子性（Atomicity）:组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有操作全部执行成功，整个事务才能提交，事务中的任何一个操作失败，已经执行的任何操作必须撤销，让数据库退回初始状态。
* 一致性（Consistency）:事务将数据库从一种状态变为下一种一致性的状态。事务开始前和事务结束后，数据库的完整性约束没有被破坏。
* 隔离性（isolation）：不同的事务用有各自的数据空间，他们的操作不会对对方产生干扰。
* 持久性（Durability）：事务一旦提交，其结果就是永久性的。即使发生宕机等故障，数据库也能将数据恢复。

## 数据并发问题

​	数据库中的相同数据可能同时被多个事务访问，如果没有采取必要的隔离措施，会导致各种并发问题，破坏数据的完整性。

### 脏读（dirty read）

​	A事务读取到了B事务尚未提交的更改数据。违反了数据库的隔离性。

### 不可重复读

​	一个事务内多次读取同一数据集合，在这个事务还没有结束时，另一个事务也访问该同一数据集合，并做一些修改。因此，在第一个事务中的两次读数据之间，两次读取到的数据可能是不一样的。	

​	A事务读取到了B事务已经提交的更改数据。

不可重复读和脏读的区别：

* 脏读是读到未提交的数据，违反了数据库的隔离性要求
* 不可重复读是读取到了已经提交的数据，违反了数据库事务一致性的要求。

### 幻象读

​	A事务读取到了B事务提交的新增数据。这事A事务将出现幻象读的问题。

幻象读和不可重复读的区别：

* 幻象读是指读取到了其他已经提交事务的新增数据
* 不可重复读是读到了已经提交事务的更改数据（更改和删除）。

### 第一类丢失更新

​	A事务撤销时，把已经提交的B事务的更新数据覆盖了

### 第二类丢失更新

​	A事务覆盖B事务已经提交的数据，造成B事务所做的操作丢失

## 隔离级别

| 隔离级别         | 脏读 | 不可重复读 | 幻象读 | 第一类丢失更新 | 第二类丢失更新 |
| ---------------- | ---- | ---------- | ------ | -------------- | -------------- |
| read uncommited  | √    | √          | √      | x              | √              |
| read committed   | x    | √          | √      | x              | √              |
| repleatable read | x    | x          | √      | x              | x              |
| Serializable     | x    | x          | x      | x              | x              |

## 事务的实现

​	事务的隔离性由锁来实现。原子性，一致性，持久性通过数据库的redo log 和undo log来实现。

​	redo log来保证事务的原子性和持久性。undo log用来保证事务的一致性。

# spring中事务的实现

## spring的事务管理器实现类

​	spring将事务管理委托给底层具体的持久化实现框架来完成。因此，Spring为不同的持久化框架提供了PlatformTransactionManager接口的实现类。

| 事务                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| org.springframework.orm.jpa.JpaTransactionManager            | 使用JPA进行持久化时，使用该事务管理器                        |
| org.springframework.orm.bibernateX.HibernateTransactionManager | 使用Hibernate进行持久化时，使用该事务管理器                  |
| org.springframework.jdbc.datasource.DataSourceTransactionManager | 使用spring JDBC或MyBatis等基于DataSource数据源进行持久化时，使用该事务管理器 |
| org.springframework.orm.jdo.JdoTransactionManager            | 使用JDO进行持久化时，使用该事务管理器                        |
| org.springframework.transaction.jta.JtaTransationManager     | 具有多个数据源的全局事务使用该管理器（不管采用何种持久化技术） |

## 事务的传播行为

​	Spring中规定了7中类型的事务传播行为，它们规定了事务方法和事务方法发生嵌套调用时事务如何进行传播的。如下表：

| 事务传播行为类型         | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| propagation_required     | 如果当前没有事务，则新建一个事务；如果已经存在一个事务，则加入到这个事务中 |
| propagation_supports     | 支持当前事务。如果当前没有事务，则以非事务方式执行           |
| propagation_mandatory    | 使用当前事务，如果当前没有事务，则抛出异常                   |
| propagation_requires_new | 新建事务。如果当前存在事务，则把当前事务挂起                 |
| propagation_not_supports | 以非事务方式执行，如果存在事务，则把当前事务挂起             |
| progatation_never        | 以非事务方式执行，如果当前存在事务，则抛出异常               |
| progatation_nested       |                                                              |

# 分布式事务

​	分布式事务是为了保证不同数据库的数据一致性。

## CAP定理

* C（一致性）：对某个指定客户端来说，读操作能返回最新的写操作。对于数据分布在不同节点上的数据来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么久成为强一致，如果有某个节点没有读取到，那就是分布式不一致。

* A（可用性）：非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应）。可用性的关键是：一个是合理的时间，一个是合理的响应。

  ​	合理的时间：值得是请求不能被无限阻塞，应该在合理的时间内给出返回

  ​	合理的响应：值得是系统应该明确返回结果，并且结果是正确的。

* P（分区容错性）：当出现网络分区后，系统能够继续工作。

  ​	在CAP定理中，三者不能共存。只能选择CP或AP架构。对于CP来说，放弃可用性，追求一致性和分区容错性。zookeeper就是追求强一致性。

  ​	对于AP来说，放弃一致性（强一致性）

## BASE

​	BASE是 basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。是对CAP中AP的一个扩展。

* 基本可用：分布式系统出现故障时，允许损失部分可用功能，保证核心功能可用
* 软状态：允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是CAP中的不一致。
* 最终一致：经过一段时间后，所有节点的数据都将会达到一致。

**BASE** : base和ACID是相反的，它完全不同于ACID的强一致性模式，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。

## 2PC（XA Transactions）

​	XA事务允许不同数据库之间的分布式事务。只要参与在全局事务中的每个节点都支持XA事务。

​	XA事务由一个或多个资源管理器（Resource Managers）、一个事务管理器（Transaction Manager）以及一个应用程序组成。

* 资源管理器：提供访问事务资源的方法。一个数据库就是一个资源管理器

* 事务管理器：协调参与全局事务中的各个事务。需要和参与全局事务的所有资源管理器进行通信

* 应用层序：定义事务的边界，指定全局事务中的操作

  分布式事务使用两段式提交（two-phase commit）的方式。

* 1、所有参与全局事务的节点都开始准备（PREPARE），告诉事务管理器它们准备好了提交了

* 2、事务管理器告诉资源管理器执行ROLLBACK还是Commit.

  如果任何一个节点显示不能提交，则所有节点都被告知需要回滚。

## TCC

## 本地消息表

## MQ事务消息





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































