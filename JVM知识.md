### 类加载过程

#### 1、加载

* 根据全限定类名获取定义此类的二进制字节流
* 将字节流所代表的静态存储结构转化为方法区的运行时数据结构
* 在内存中生成代表此类的java.lang.Class对象

#### 2、验证

##### 文件格式验证

​	字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。

##### 元数据验证

​	对字节码描述信息进行语义分析，保证其描述的信息符合java语言规范（语法校验）

##### 字节码验证

​	对类的方法体进行校验分析，保证被校验的类的方法在运行时不会做出危害虚拟机安全的事件。

##### 符号引用验证

​	该校验发生在虚拟机将符号引用转化为直接引用的时候。

#### 3、准备

​	正式为类变量分配内存并设置类变量初始值的阶段，这些变量锁使用的内存都将在方法区进行分配。

​	**注意** ： 这个时候进行内存分配的仅包括【类变量（被static修饰的变量）】，而不包括实例变量。

​		     这里所说的初始值“通常情况”下，是数据类型的零值

```java 
public static in value = 124;
/**
*  变量value在准备阶段过后的初始值是0，而不是124。
*  因为这个时候尚未开始执行任何的java方法
/
```

#### 4、解析

​	解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程.

#### 5、初始化

​	类初始化时类加载过程的最后一步。到了初始化阶段，才真正开始执行类中定义的java程序代码。

### 类加载器

##### 双亲委派模型

​	如果一个类加载器收到了类加载得到请，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终应该传送到顶层的类加载器中，只有当父加载器反馈自己无法完成这个请求的加载（它的搜索范围中没有找到所需的类）时，子加载器才会尝试去自己加载



### 引用算法

#### 引用计数法

##### 定义

​	给对象中添加一个引用计算器，每当有一个地方引用它时，计算器值就加1；当引用失效时，计数器值就减1；任何时刻计算器都为0的对象就是不可能再被使用的

##### 有点

​	实现简单，判定效率也较高

##### 缺点

​	很难解决对象之间的相互循环引用的问题

```java 
//例如：对象objA和objB都有字段instance,
objA.instance = objB
objB.instance = objA
//因为它们相互循环引用，它们的引用计数器不为0，GC收集器无法回收他们
```



#### 根搜索算法

##### 思路

​	通过一系列的名为```GC Roots```的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC roots没有任何引用链相连时，则证明此对象时不可用的。

```shell
# 在Java语言中，可用作GC Roots的对象包括下面几种：
# 1、虚拟机栈（栈帧中的本地变量表）中引用的对象
# 2、方法区中的类静态属性引用的对象
# 3、方法区中的常量引用的对象
# 4、本地方法栈中JNI(Native方法)的引用的对象
```



### 垃圾收集算法

#### 标记-清除算法

##### 定义

​	首先标记出所有需要回收的对象，在标记完成后同一回收掉所有被标记的对象

##### 缺点

1、效率问题：标记和清除过程效率都不高

2、空间问题：会产生大量不连续的内存碎片

#### 复制算法

##### 定义

​	它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当一块空间的内存用完了，就将还活着的对象复制到另一块上面，然后再把已使用过的内存空间一次性清理掉。

##### 优点

​	实现简单，运行高效

##### 缺点

​	 内存缩小了一半，代价太大

#### 标记-整理算法

​	标记过程和【标记-清除】算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界意外的内存

#### 分代收集算法

​	根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。

​	新生代中，每次垃圾收集时都发现有大批的对象死去，只有少量存活，那就选用【复制算法】，只需付出少量存活对象的复制成本就可以完成收集

​	老年代中，因为对象存活率高，没有额外的空间对它进行分配担保，就必须使用【标记-清理】或【标记-整理】算法

### 垃圾收集器

![1563798003382](.\img\garbage1.png)

存在连线的，说明他们可以搭配使用。

#### Serial 收集器

​	Serial收集器时最基本，历史最悠久的收集器。

​	它是一个【单线程的收集器】。单线程不仅仅是它只会使用一个CPU或一个收集线程去完成垃圾收集工作。

​	更重要的是在它进行垃圾收集时，必须暂停其他所有工作线程

![1563537061885](D:\data\md笔记\img\Serial.png)

#### ParNew收集器

​	Serial收集器的多线程版本。

![1563537220804](D:\data\md笔记\img\parNew.png)

#### Parallel Scavenge收集器

​	是一个新生代收集器，也是使用复制算法的收集器，又是并行的多线程收集器。

##### 特点

​	Parallel Scavenge收集器的目标是：达到一个可控制的吞吐量。所谓的吞吐量是CPU用于运行用户代码的时间与CPU总消耗时间的比值。

​	吞吐量 = 运行用户代码时间/(运行用户代码时间+ 垃圾收集时间)

#####  参数

​	Parallel Scavenge 收集器提供了两个参数

| 参数              | 说明                     |
| ----------------- | ------------------------ |
| -XX:MaxGCPauseMil | 控制最大垃圾回收停顿时间 |
| -XX:GCTimeRatio   | 设置吞吐量大小的         |

#### Serial Old收集器

​	Serial Old是Serial收集器的老年代版本。

#### Parallel Old收集器

​	是Parallel Scavenge收集器的老年代版本。这个收集器是在JDK1.6中才开始的

![1563537484516](D:\data\md笔记\img\ParallelOld.png)

#### CMS收集器

​	CMS(Concurrent Mark Sweep)收集器是一种以：获取最短回收停顿时间为目标的收集器。

​	CMS收集器是基于“标记-清除“算法实现的。

​	整个过程分为4个步骤：

* 初始标记
* 并发标记
* 重新标记
* 并发清除

```shell
# 初始标记、重新标记这两个步骤仍然需要 stop-the-world

# 初始标记  仅仅是只是标记一下GC Roots能直接关联到的对象，速度很快
# 并发标记  就是进行GC Root Tracing的过程
# 重新标记	为了修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这一部分比初始标记时间长，但是远比并发标记的时间短
```

![1563538388394](D:\data\md笔记\img\CMS.png)

​	缺点：

* CMS收集器对CPU资源非常敏感
* CMS收集器无法处理浮动垃圾
* 基于标记-清除收集算法，会产生大量的空间碎片

#### G1收集器

​	G1(Garbage First)收集器是当前收集器技术发展的最新成果。

​	G1收集器与CMS收集器相比有两个显著的改进：

*  基于"标记-整理"算法，不会产生空间碎片

* 它可以精确的控制停顿。既能让使用者明确的指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒

  ```shell
  # G1收集器可以实现在基本不牺牲吞吐量的前提下完成低停顿的内存回收，这是由于它能够极力的避免全区域的垃圾收集.
  # 之前的收集器都是在真个新生代或老年代进行收集的
  # 而G1整个Java 堆（包括新生代，老年代）划分为多个大小固定的独立区域，并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域。
  ```

#### 参数总结

| 参数                           | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| UseSerialGC                    | 虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old 的收集器组合进行垃圾回收 |
| UseParNewGC                    | 打开此开关后，使用ParNew + Serial Old的收集器组合进行内存收回 |
| UseConcMarkSwppeGC             | 打开此开关后，使用ParNew + CMS + Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用 |
| UseParallelGC                  | 虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old的收集器组合进行内存回收 |
| UseParallelOldGC               | 打开此开关后，使用Parallel Scavenge + <br>Parallel Old 的收集器组合进行内存回收 |
| SurvivorRatio                  | 新生代中Eden区域与Survivor区域的容量比值，默认为8。代表：Eden:Survivor = 8:1 |
| PretenureSizeThreshold         | 直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配 |
| MaxTenuringThreshold           | 晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC 之后，年龄就加1，当超过这个参数值时就进入老年代 |
| UseAdaptiveSizePolicy          | 动态调整Java堆中各个区域的大小已经进入老年代的年龄。         |
| HandlePromotionFailure         | 是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况 |
| ParallelGCThreads              | 设置并行GC时进行内存回收的线程数                             |
| GCTimeRatio                    | GC时间占总时间的比例，默认值为99，即允许1%的GC时间。仅在使用Parallel Scavenge 收集器时生效。 |
| MaxGCPauseMillis               | 设置GC的最大停顿时间。仅在使用Paralllel Scavenge收集器时生效 |
| CMSInitiatingOccupancyFraction | 设置CMS收集器在老年代空间被使用多少后出发垃圾收集。默认值为68%，仅在CMS收集器时有效 |
| UseCMSCompactAtFullCollection  | 设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。    |
| CMSFullGCsBeforeCompaction     | 设置CMS收集器在进行若干次垃圾收集后再启动一次内存整理。      |






# JVM指令集

## 未归类

| 指令码 | 助记符      | 说明           |
| ------ | ----------- | -------------- |
| 0x00   | nop         | 什么都不做     |
| 0x01   | aconst_null | 将null推至栈顶 |

## const

| 指令码 | 助记符    | 说明                |
| ------ | --------- | ------------------- |
| 0x02   | iconst_m1 | 将int(-1)推至栈顶   |
| 0x03   | iconst_0  | 将int(0)推至栈顶    |
| 0x04   | iconst_1  | 将int(1)推至栈顶    |
| 0x05   | iconst_2  | 将int(2)推至栈顶    |
| 0x06   | iconst_3  | 将int(3)推至栈顶    |
| 0x07   | iconst_4  | 将int(4)推至栈顶    |
| 0x08   | iconst_5  | 将int(5)推至栈顶    |
| 0x09   | lconst_0  | 将long(0)推至栈顶   |
| 0x0a   | lconst_1  | 将long(1)推至栈顶   |
| 0x0b   | fconst_0  | 将float(0)推至栈顶  |
| 0x0c   | fconst_1  | 将float(1)推至栈顶  |
| 0x0d   | fconst_2  | 将float(2)推至栈顶  |
| 0x0e   | dconst_0  | 将double(0)推至栈顶 |
| 0x0f   | dconst_1  | 将double(1)推至栈顶 |

## push

| 指令码 | 助记符 | 说明                                 |
| ------ | ------ | ------------------------------------ |
| 0x10   | bipush | 将单字节整型（-127~127）推至栈顶     |
| 0x11   | sipush | 将短整型常量（-32768~32767）推至栈顶 |

## idc

| 指令码 | 助记符 | 说明 |
| ------ | ------ | ---- |
| 0x12   | idc    |      |
| 0x13   | idc_w  |      |
| 0x14   | idc2_w |      |

## load

| 指令码 | 助记符 | 说明 |
| ------ | ------ | ---- |
| 0x15   | iload  |      |
| 0x16   | lload  |      |
| 0x17   | fload  |      |
| 0x18   | dload  |      |
| 0x19   | aload  |      |
| 0x1a   |        |      |
| 0x1b   |        |      |
| 0x1c   |        |      |
| 0x1d   |        |      |











