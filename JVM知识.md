### 类加载过程

#### 1、加载

* 根据全限定类名获取定义此类的二进制字节流
* 将字节流所代表的静态存储结构转化为方法区的运行时数据结构
* 在内存中生成代表此类的java.lang.Class对象

#### 2、验证

##### 文件格式验证

​	字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。

##### 元数据验证

​	对字节码描述信息进行语义分析，保证其描述的信息符合java语言规范（语法校验）

##### 字节码验证

​	对类的方法体进行校验分析，保证被校验的类的方法在运行时不会做出危害虚拟机安全的事件。

##### 符号引用验证

​	该校验发生在虚拟机将符号引用转化为直接引用的时候。

#### 3、准备

​	正式为类变量分配内存并设置类变量初始值的阶段，这些变量锁使用的内存都将在方法区进行分配。

​	**注意** ： 这个时候进行内存分配的仅包括【类变量（被static修饰的变量）】，而不包括实例变量。

​		     这里所说的初始值“通常情况”下，是数据类型的零值

```java 
public static in value = 124;
/**
*  变量value在准备阶段过后的初始值是0，而不是124。
*  因为这个时候尚未开始执行任何的java方法
/
```

#### 4、解析

​	解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程.

#### 5、初始化

​	类初始化时类加载过程的最后一步。到了初始化阶段，才真正开始执行类中定义的java程序代码。

### 类加载器

##### 双亲委派模型

​	如果一个类加载器收到了类加载得到请，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终应该传送到顶层的类加载器中，只有当父加载器反馈自己无法完成这个请求的加载（它的搜索范围中没有找到所需的类）时，子加载器才会尝试去自己加载



### 引用算法

#### 引用计数法

##### 定义

​	给对象中添加一个引用计算器，每当有一个地方引用它时，计算器值就加1；当引用失效时，计数器值就减1；任何时刻计算器都为0的对象就是不可能再被使用的

##### 有点

​	实现简单，判定效率也较高

##### 缺点

​	很难解决对象之间的相互循环引用的问题

```java 
//例如：对象objA和objB都有字段instance,
objA.instance = objB
objB.instance = objA
//因为它们相互循环引用，它们的引用计数器不为0，GC收集器无法回收他们
```



#### 根搜索算法

##### 思路

​	通过一系列的名为```GC Roots```的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC roots没有任何引用链相连时，则证明此对象时不可用的。

```shell
# 在Java语言中，可用作GC Roots的对象包括下面几种：
# 1、虚拟机栈（栈帧中的本地变量表）中引用的对象
# 2、方法区中的类静态属性引用的对象
# 3、方法区中的常量引用的对象
# 4、本地方法栈中JNI(Native方法)的引用的对象
```



### 垃圾收集算法

#### 标记-清除算法

##### 定义

​	首先标记出所有需要回收的对象，在标记完成后同一回收掉所有被标记的对象

##### 缺点

1、效率问题：标记和清除过程效率都不高

2、空间问题：会产生大量不连续的内存碎片

#### 复制算法

##### 定义

​	它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当一块空间的内存用完了，就将还活着的对象复制到另一块上面，然后再把已使用过的内存空间一次性清理掉。

##### 优点

​	实现简单，运行高效

##### 缺点

​	 内存缩小了一半，代价太大

#### 标记-整理算法

​	标记过程和【标记-清除】算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界意外的内存

#### 分代收集算法

​	根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。

​	新生代中，每次垃圾收集时都发现有大批的对象死去，只有少量存活，那就选用【复制算法】，只需付出少量存活对象的复制成本就可以完成收集

​	老年代中，因为对象存活率高，没有额外的空间对它进行分配担保，就必须使用【标记-清理】或【标记-整理】算法

### 垃圾收集器

#### Serial 收集器

​	Serial收集器时最基本，历史最悠久的收集器。

​	它是一个【单线程的收集器】。单线程不仅仅是它只会使用一个CPU或一个收集线程去完成垃圾收集工作。

​	更重要的是在它进行垃圾收集时，必须暂停其他所有工作线程

#### ParNew收集器

​	Serial收集器的多线程版本。

#### Parallel Scavenge收集器

​	是一个新生代收集器，也是使用复制算法的收集器，又是并行的多线程收集器。

##### 特点

​	Parallel Scavenge收集器的目标是：达到一个可控制的吞吐量。所谓的吞吐量是CPU用于运行用户代码的时间与CPU总消耗时间的比值。

​	吞吐量 = 运行用户代码时间/(运行用户代码时间+ 垃圾收集时间)

#####  参数

​	Parallel Scavenge 收集器提供了两个参数

| 参数              | 说明                     |
| ----------------- | ------------------------ |
| -XX:MaxGCPauseMil | 控制最大垃圾回收停顿时间 |
| -XX:GCTimeRatio   | 设置吞吐量大小的         |

#### Serial Old收集器

#### Parallel Old收集器

#### CMS收集器

#### G1收集器







# JVM指令集

## 未归类

| 指令码 | 助记符      | 说明           |
| ------ | ----------- | -------------- |
| 0x00   | nop         | 什么都不做     |
| 0x01   | aconst_null | 将null推至栈顶 |

## const

| 指令码 | 助记符    | 说明                |
| ------ | --------- | ------------------- |
| 0x02   | iconst_m1 | 将int(-1)推至栈顶   |
| 0x03   | iconst_0  | 将int(0)推至栈顶    |
| 0x04   | iconst_1  | 将int(1)推至栈顶    |
| 0x05   | iconst_2  | 将int(2)推至栈顶    |
| 0x06   | iconst_3  | 将int(3)推至栈顶    |
| 0x07   | iconst_4  | 将int(4)推至栈顶    |
| 0x08   | iconst_5  | 将int(5)推至栈顶    |
| 0x09   | lconst_0  | 将long(0)推至栈顶   |
| 0x0a   | lconst_1  | 将long(1)推至栈顶   |
| 0x0b   | fconst_0  | 将float(0)推至栈顶  |
| 0x0c   | fconst_1  | 将float(1)推至栈顶  |
| 0x0d   | fconst_2  | 将float(2)推至栈顶  |
| 0x0e   | dconst_0  | 将double(0)推至栈顶 |
| 0x0f   | dconst_1  | 将double(1)推至栈顶 |

## push

| 指令码 | 助记符 | 说明                                 |
| ------ | ------ | ------------------------------------ |
| 0x10   | bipush | 将单字节整型（-127~127）推至栈顶     |
| 0x11   | sipush | 将短整型常量（-32768~32767）推至栈顶 |

## idc

| 指令码 | 助记符 | 说明 |
| ------ | ------ | ---- |
| 0x12   | idc    |      |
| 0x13   | idc_w  |      |
| 0x14   | idc2_w |      |

## load

| 指令码 | 助记符 | 说明 |
| ------ | ------ | ---- |
| 0x15   | iload  |      |
| 0x16   | lload  |      |
| 0x17   | fload  |      |
| 0x18   | dload  |      |
| 0x19   | aload  |      |
| 0x1a   |        |      |
| 0x1b   |        |      |
| 0x1c   |        |      |
| 0x1d   |        |      |











