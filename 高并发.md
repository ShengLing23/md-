# JDK并发包

## 团队协作：同步控制

### ReentrantLock

* 与关键字``Synchronized`` 相比，``ReentrantLock``有着显示的操作过程。开发人员必须手动指定何时加锁，何时解锁。
* 对于``Synchronized``来说，处于等待状态的线程，只有两种结果，
  * 获得锁执行
  * 继续等待

* 而对于``ReentrantLock``,则提供另一种可能，即响应中断。

### Condition

### Semaphore

​	允许多个线程同时访问。无论是synchronized还是ReentrantLock，一次都只允许一个线程访问一个资源。而信号量却可以指定多个线程，同时访问一个资源。

```java
public Semaphore(int permits)
public Semaphore(int permits,boolean fair) //第二个参数指定是否公平    
```

在构造信号量对象时，必须设置准入参数，及同时能申请多少个许可。

```java
public void acquire();
public void acquireUninterruptibly()；
public boolean tryAcquire();
public boolean tryAcquire(long timeout, TimeUnit unit)；
public void release()
```

* acquire()方法尝试获取一个准入的许可。若无法获得，则线程等待。直到有线程释放许可，或被中断。
* acquireUninterruptibly()和acquire()方法类似，但是不响应中断
* tryAcquire()方法尝试获取一个准入许可，如果成功，返回true；失败，返回false.不进行等待。立即返回
* release()：在线程访问资源结束后，释放一个许可。

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;

public class SemaDemo implements Runnable {
	final Semaphore semp = new Semaphore(5);
	@Override
	public void run() {
		
		try {
			semp.acquire();
			Thread.sleep(2000);
			System.out.println(Thread.currentThread().getId()+":done");
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} finally{
			semp.release();
		}
				
	}
	public static void main(String[] args) {
		ExecutorService  exec = Executors.newFixedThreadPool(30);
		final SemaDemo demo = new SemaDemo();
		for(int i=0;i<30;i++){
			exec.submit(demo);
		}
	}
}
```

### ReadWriteLock

### CountDownLatch

​	是一个非常实用的多线程控制工具类。等待所有线程执行完毕后，再执行下面的程序。

```java
public CountDownLatch(int count);//参数：当前计数器的计数个数
```

```java
import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CountDownLatchDemo implements  Runnable{
	static final CountDownLatch end = new CountDownLatch(10);
	static final CountDownLatchDemo demo = new CountDownLatchDemo();

	@Override
	public void run() {
		try {
			Thread.sleep(new Random().nextInt(10)*1000);
			System.out.println("Check over");
			end.countDown();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public static void main(String[] args) {
		ExecutorService pool = Executors.newFixedThreadPool(10);
		for(int i=0;i<10;i++){
			pool.submit(demo);
		}
		try {
			end.await();
			System.out.println("fire...");
			pool.shutdown();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
```

### CyclicBarrier（循环栅栏）

​	CyclicBarrier是另外一种多线程并发控制工具。

​	使用场景：司令下达命令，要求10个士兵一起完成一项任务。这是会要求10个士兵先集合报道，接着，一起去执行任务。当10个士兵把自己手上的任务都执行完了，任务才算完成。

​	CyclicBarrier比CountDownLatch略微强大一些，它可以接受一个参数为barrierAction.所谓的barrierAction就是当计数器一次计数完成后，系统会执行的动作。

```java
public CyclicBarrier(int parties,Runnable barrierAction);
// parties表示计数总数
```

### LockSupport

### Guava和RateLimiter

## 线程服务：线程池

## 轮子：JDK的并发容器

### 并发集合简介

- ConcurrentHashMap：高效的并发HashMap.线程安全的HashMap
- CopyOnWriteArrayList：在读多写少的场景，这个List的性能非常好
- ConcurrentLinkedQueue：高效的并发队列，使用链表实现。
- BlockingQueue：表示阻塞队列
- ConcurrentSkipListMap：跳表的实现。





























