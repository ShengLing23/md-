## 设计模式分类

### 创建型

​	抽象了对象实例化过程，用来帮助创建对象的实例

#### 单例模式

```shell
# 保证一个类仅有一个实例，并提供一个访问它的全局访问点	
```

> 单例模式有两种典型的解决方案，一种叫懒汉式，一种叫饿汉式
>
> > 懒汉式
> >
> > > ```java
> > > //懒汉式实现方式
> > > public class Singleton{
> > >     private static Singleton instance = null;
> > >     private Singleton(){}
> > >     public static Singleton(){
> > >         if (instance == null){
> > >             instance = new Singleton();
> > >         }
> > >         return instance;
> > >     }
> > > }
> > > ```
> > >
> > > 懒汉式实现方式体现了延迟加载的思想。
> >
> > 饿汉式
> >
> > > ```java
> > > //饿汉式
> > > public class Singleton{
> > >     private static Singleton instance 
> > >         					= new Singleton();
> > >     private Singleton(){}
> > >     public static Singleton(){
> > >         return instance;
> > >     }
> > > }
> > > ```
> > >
> > > 饿汉式采用了java中的static的特性
> > >
> > > * static变量在类装载的时候进行初始化
> > > * 多个实例的static变量共享同一块内存区域

```shell
# 单例模式的优缺点：
1、时间和空间
   懒汉式是典型的时间换空间，每次获取都会进行判断，看是否需要创建实例。浪费时间。
   饿汉式是典型的空间换时间，当类装载时创建实例，不管是否使用，先创建。
2、线程安全
   懒汉式：不加同步的懒汉式是线程不安全的。
   饿汉式：是线程安全的，因为虚拟机保证只会加载一次
   
3、如何实现懒汉式的线程安全：
   public static synchronized Singleton getInstance(){...}
   但是这样会降低访问速度，而且每次都要判断，有没有更好的方式来实现呢？
   可以使用双重检查加锁的方式实现，即可实现线程安全，又能使性能不受很大的影响。
```

> 双重检查加锁
>
> > ```JAVA
> > public static Singleton getInstance(){
> >     if (instance == null){
> >         synchronized(Singleton.class){
> >             if (instance == null){
> >                 instance = new Singleton();
> >             }
> >         }
> >     }
> >     return instance
> > }
> > ```

***

​		更加上面的分析，常见的两种单例的实现方式都存在小小的缺陷，那么有没有一种方案，既能够实现延迟加载，又能够实现线程安全呢？

```shell
# 这个解决方案被称为：Lazy Initialization holder class模式
# 这个模式综合使用了java的类级内部类和多线程缺省同步锁的知识
```

> 相应的基础知识
>
> > 类级内部类
> >
> > > * 什么是类级内部类
> > >   * 类级内部类就是：有static修饰的成员式内部类。
> > >   * 没有static修饰的成员内部类被称之为对象级内部类
> > > * 类级内部类相当于其外部类的static成分，它的对象与外部类的对象不存在依赖关系，因此可直接创建。而对象级内部类的实例是绑定在外部对象实例中的
> > > * 类级内部类中，可以定义静态的方法。在静态方法中只能够引用外部类中的静态成员变量或者成员方法
> > > * 类级内部类相当于其外部类的成员，并且在第一次被使用时才会被装载
> >
> > 缺省同步锁
> >
> > > 在多线程开发中，为了解决并发问题，主要通过使用synchronized来家互斥锁进行同步控制，但是在某些情况下，JVM已经隐含式的为你执行了同步，这些情况下就不用自己再来进行同步控制了
> > >
> > > * 由静态初始化器(在静态字段上或static{}块中的初始化器)初始化数据时
> > > * 访问final字段时
> > > * 在创建线程之前创建对象时
> > > * 线程可以看见它将要处理的对象时
>
> 实现
>
> > ```java
> > public class Singleton{
> >     private static class SingletonHolder{
> >         private static Singleton instance 
> >             		= new Singleton();
> >     }
> >     private Singleton(){}
> >     public static Singleton getInstance(){
> >         return SingletonHolder.instance;
> >     }
> > }
> > ```

#### 工厂方法模式

​	定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到子类。

#### 抽象工厂模式

​	提供一个用于创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类

#### 生成器模式

​	将一个复杂对象的构建与它的表示分离，使得同样的过程可以创建不同的表示

#### 原型模式

​	用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象

### 结构型

​	描述如何组合类和对象以获得更大的结构

#### 外观模式

​	为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用

#### 适配器模式

​	将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本接口不兼容而不能一起工作的那些类可以一起工作

#### 代理模式

 	为其他对象提供一种代理以控制对这个对象的访问

#### 组合模式

​	将对象组合成树形结构表示“整体-部分”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

#### 享元模式

​		运用共享技术有效的支持大量细粒度的对象

#### 装饰器模式

​		

#### 桥接模式

​		将抽象部分与它的实现部分分离，使它们都可以独立的变化。

### 行为型

​	描述算法和对象间职责的分配

#### 中介者模式

​		用一个中介对象封装一系列的对象交互。中介者使得各个对象不需要显示的相互引用，从而使其耦合松散，而且可以独立的改变它们之间的交互。

#### 观察者模式

​		定义对对象将的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

#### 命令模式

​		将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。

#### 迭代器模式

​		提供一种方法顺序访问一个聚合对象中的各个元素，而又不需暴露该对象的内部表示。

#### 模板方法模式

​		定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。

#### 策略模式

​		定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。本模式使得算法可独立与使用它的客户而变化。

#### 状态模式

​		允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

#### 备忘录模式

​		在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样，以后就可以将该对象恢复到原先保存的状态。

#### 解释器模式

​		给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

#### 职责链模式

​		使很多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

#### 访问者模式

​		表示一个作用于某个对象结构中的各元素的操作。它使得你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。