## 8086处理器

### 寄存器

#### 通用寄存器

8086处理器内部有8个16位通用寄存器，被命名为：

| AX   | BX   | CX   | DX   | SI   | DI   | BP   | SP   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

其中，前四个：AX、BX、CX、DX又能各自拆分为两个8位的寄存器来使用，总共可以提供8个8位的寄存器：

AH、AL、BH、BL、CH、CL、DH、DL

#### 段寄存器

* CS (Code Segment) :代码段寄存器
* DS(Data Segment)：数据段寄存器
* ES(Extra Segment)：附加段寄存器
* SS：栈段寄存器
* IP：指令指针寄存器


【ip】指令指针寄存器【只能】和【CS】一起使用，只有【处理器】才能改变它的内容。

当一段代码开始的时候，CS指向代码段的【起始地址】，IP指向【段内偏移】。有CS和IP共同形成逻辑地址。

#### 标志位寄存器

* 【零标志位】ZF：当处理器执行完一条算术或逻辑指令后，结果除了送到指定的位置（目的操作数指定位置）后，还送到一个或非门。输入全部为0，结果为1，输入不全为0，结果为0 。因此【计算结果为0，ZF=1;否则，ZF=0】
* 【方向标志位】DF：【DF=0，正方向；DF=1，反方向】【cld指令将DF置为0，std指令将DF置为1】
* 【奇偶标志位】PF：运算结果出来后，如果低8位中，有偶数个1，则PF=1；否则DF=0
* 【进位标志位】CF：当处理器进行算术操作时，如果最高位有向前进位或借位的情况时，CF=1,否则CF=0
* 【溢出标志位】OF：如果进行的是有符号运算，结果超出了目标操作数所容纳的范围，则OF=1,否则OF=0

### 重定位难题

​	处理器是自动化的器件，在给出了起始地址后，它将从这个地址开始，取出每条指令并加以执行。只有每条指令都正确无误，它就能准确的知道下一条指令的地址。

#### 物理地址

真实的内存地址，又称为物理地址。

如果在程序中使用物理地址，那么这样的程序是无法重定位的。

#### 逻辑地址

​	在采取了分段策略后，一个内存单元的地址就可以使用【段：偏移】或者【段地址：偏移地址】来表示。这就是通常所说的逻辑地址

### 加电复位

​	对于8086处理器来说，加电复位后代【码段寄存器CS】的内容为【0xFFFF】,其他所有的寄存器的内容为【0x0000】,包括指令指针寄存器。

### 基本输入输出系统

​	8086处理器可以访问1MB内容的内存，地址范围为：0x00000 到 0xFFFFF .。

​	在Intel 8086处理器中，ROM占据着整个内存顶端的64KB,物理地址为：0xF0000~0xFFFFF,里面固话了开机时要执行的指令。DRAM占据着较低端的640KB,地址范围为：0x00000~0x9FFFF;中间还有一部分，分给了其他的外围设备。

# 汇编

## 标号

​	在编译阶段，每条指令都被计算并赋予了一个汇编地址。当编译好的程序加载到物理内存后，它在段内的偏移地址和他在编译阶段的汇编地址是相同的。

​	在NASM汇编语言中，每条指令前面都可以拥有一个标号，以代表和指示该条指令的汇编地址。

```shell
# 格式一
infi : jmp near infi
# 格式二
infi jmp near infi 
# 格式三
infi:
	jmp near infi 
```

## 声明并初始化数据

* DB——指令，用来声明字节。跟在它后面的操作数都占一个字节的长度。如果要声明超过一个以上的数据，各个操作数之间必须以逗号隔开。
* DW——指令(双字节)，用来声明字数据
* DD——指令，用来声明双字数据
* DQ——指令，用来声明四字数据

## 伪指令

​	DB,DW,DD,DQ不是处理器指令，只是编译器提供的汇编指令，所以被称为伪指令。

​	伪指令是汇编指令的一种，它没有对应的集器指令。

# 指令

## jmp

```shell
jmp 0xf000 : 0xe05b
# 0xf000 是要跳转的段地址
# 0xe05b 是目标端内的偏移地址

# 无限循环
infi:jmp near infi
# 关键字near表示目标位置仍在当前的代码段内。
```

## mov

```shell
mov 目的操作数，源操作数
# mov指令用于数据传送
# 目的操作数应该时一个容器，故：必须是通用寄存器或者内存单元
# 源操作数，可以是和目的操作数具有相同宽度的通用寄存器，内存单元还可以是立即数。
# 目的操作数 和 源操作数 不允许同时为内存单元

# 实例
mov byte [es:0x00],'L'
# 当前的mov指令是将立即数送到内存单元，目的操作数是内存单元，操作数是立即数。
# 为了访问内存单元，需要给出段地址和偏移地址。
# 一般情况下，如果没有任何附加提示，段地址默认在寄存器DS中。
# 当我们希望使用ES来访问内存时，使用段超越前缀“es:”，这说明我们明确要求处理器在生成物理地址时，使用段寄存器ES.
# 还要注意：目的数是一个内存地址，所以要用方括号括起来
# 最后，关键字 byte用来修饰目的操作数，指出本次传送是以字节的方式执行的。
```

## div

​	除法指令。它可以做两种类型的出发。

* 用16位的二进制数除以8位的二进制数。
  * 在这种情况下，被除数必须在寄存器AX中。必须事先传送到AX寄存器中。除数可以由8位的通用寄存器或者内存单元提供
  * 商放在AL中，余数挡在 AH中

* 用32位的二进制数除以16位的二进制数。
  * 在这种情况下，因为16位的处理器无法直接提供32位的被除数。故【被除数的高16位在DX中，低16位在AX中】
  * 商在AX中，余数在DX中

## xor

* 异或。
* 指令的目的操作数可以是通用寄存器和内存单元。
* 源操作数：可以是通用寄存器、内存单元和立即数
* 不允许两个操作数同时位内存单元

```shell
0 xor 0 = 0
0 xor 1 = 1
1 xor 0 = 1
1 xor 1 = 0
```

## movsb和movsw

​	这两个指令通常用于把数据从内存的一个地方批量的传送（复制）到另一个地方。处理器把他们看成是数据串。

​	movsb的传送是以字节为单位，而movsw的传送是以字为单位。

```shell
# movsb 和movsw 指令执行时：
# 原始数据串的段地址由【DS】指定，偏移地址由【SI】指定，简写为【DS:SI】
# 目的地址由【ES:DI】指定
# 传输的字节数（movsb）或字数（movsw）由【CX】指定
# 还要指定正向传送还是反向传送。【正向传送】是：传送的方向是从内存区的低地址到高地址。【反向传送】则相反。
# 正向传送时，每传送一个字节或者字，SI和DI加1或加2
# 每传送一次，CX的内容自动减一。
```

​	movsb 和 movsw 没有操作数

​	单纯的movsb和movsw 只能执行一次。如果希望反复执行，则需要加上指令前缀：【rep】—意思是：CX不为0则重复。

## loop

循环指令：重复执行一段相同的代码。处理器执行它时，会做两件事情

```shell
# 将寄存器CX内容减一
# 如果CX内容不为0，则转移到指定的位置执行，否则顺序执行后面的指令

loop digit
# 在编译阶段，编译器用digit处的汇编地址减去loop指令的汇编地址，再减去loop指令的长度（2）得到的
```

