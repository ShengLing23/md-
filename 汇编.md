## 8086处理器

### 寄存器

#### 通用寄存器

8086处理器内部有8个16位通用寄存器，被命名为：

| AX   | BX   | CX   | DX   | SI   | DI   | BP   | SP   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

其中，前四个：AX、BX、CX、DX又能各自拆分为两个8位的寄存器来使用，总共可以提供8个8位的寄存器：

AH、AL、BH、BL、CH、CL、DH、DL

* SI：源索引寄存器
* DI：目标索引寄存器
* BP： 
* SP：栈指针

#### 段寄存器

* CS (Code Segment) :代码段寄存器
* DS(Data Segment)：数据段寄存器
* ES(Extra Segment)：附加段寄存器
* SS：栈段寄存器
* IP：指令指针寄存器


【ip】指令指针寄存器【只能】和【CS】一起使用，只有【处理器】才能改变它的内容。

当一段代码开始的时候，CS指向代码段的【起始地址】，IP指向【段内偏移】。有CS和IP共同形成逻辑地址。

#### 标志位寄存器

* 【零标志位】ZF：当处理器执行完一条算术或逻辑指令后，结果除了送到指定的位置（目的操作数指定位置）后，还送到一个或非门。输入全部为0，结果为1，输入不全为0，结果为0 。因此【计算结果为0，ZF=1;否则，ZF=0】
* 【方向标志位】DF：【DF=0，正方向；DF=1，反方向】【cld指令将DF置为0，std指令将DF置为1】
* 【奇偶标志位】PF：运算结果出来后，如果低8位中，有偶数个1，则PF=1；否则DF=0
* 【进位标志位】CF：当处理器进行算术操作时，如果最高位有向前进位或借位的情况时，CF=1,否则CF=0
* 【溢出标志位】OF：如果进行的是有符号运算，结果超出了目标操作数所容纳的范围，则OF=1,否则OF=0

### 重定位难题

​	处理器是自动化的器件，在给出了起始地址后，它将从这个地址开始，取出每条指令并加以执行。只有每条指令都正确无误，它就能准确的知道下一条指令的地址。

#### 物理地址

真实的内存地址，又称为物理地址。

如果在程序中使用物理地址，那么这样的程序是无法重定位的。

#### 逻辑地址

​	在采取了分段策略后，一个内存单元的地址就可以使用【段：偏移】或者【段地址：偏移地址】来表示。这就是通常所说的逻辑地址

### 加电复位

​	对于8086处理器来说，加电复位后代【码段寄存器CS】的内容为【0xFFFF】,其他所有的寄存器的内容为【0x0000】,包括指令指针寄存器。

### 基本输入输出系统

​	8086处理器可以访问1MB内容的内存，地址范围为：0x00000 到 0xFFFFF .。

​	在Intel 8086处理器中，ROM占据着整个内存顶端的64KB,物理地址为：0xF0000~0xFFFFF,里面固话了开机时要执行的指令。DRAM占据着较低端的640KB,地址范围为：0x00000~0x9FFFF;中间还有一部分，分给了其他的外围设备。

### 寻址

​	在8086处理器中，如果要用寄存器来提供偏移地址，则必须使用【BX】【BP】【DI】【SI】。

#### 寄存器寻址

​	操作的数可以从寄存器中获取，即为寄存器寻找

#### 立即寻址

​	指令的操作数是一个立即数。

#### 内存寻找

​	内存寻址，就是寻找偏移地址（就是在指令中如何提供偏移地址偏移，供处理器访问内存用）

##### 直接寻找

​	使用该寻址方式的操作数是一个偏移地址	

```shell
mov ax,[0x5c0f]
add word [0x2030],0x50000
```

##### 基址寻址

​	很多时候，我们会有一大堆数据处理，他们通常挨在一起，顺序存放。比如：

```shell
buffer dw 0x20,0x100,0x0f,0x300
```

##### 变址寻址

##### 基址变址寻址

# 汇编

## 标号

​	在编译阶段，每条指令都被计算并赋予了一个汇编地址。当编译好的程序加载到物理内存后，它在段内的偏移地址和他在编译阶段的汇编地址是相同的。

​	在NASM汇编语言中，每条指令前面都可以拥有一个标号，以代表和指示该条指令的汇编地址。

```shell
# 格式一
infi : jmp near infi
# 格式二
infi jmp near infi 
# 格式三
infi:
	jmp near infi 
```

## 声明并初始化数据

* DB——指令，用来声明字节。跟在它后面的操作数都占一个字节的长度。如果要声明超过一个以上的数据，各个操作数之间必须以逗号隔开。
* DW——指令(双字节)，用来声明字数据
* DD——指令，用来声明双字数据
* DQ——指令，用来声明四字数据

## 伪指令

​	DB,DW,DD,DQ不是处理器指令，只是编译器提供的汇编指令，所以被称为伪指令。

​	伪指令是汇编指令的一种，它没有对应的集器指令。

# 指令

## jmp

```shell
jmp 0xf000 : 0xe05b
# 0xf000 是要跳转的段地址
# 0xe05b 是目标端内的偏移地址

# 无限循环
infi:jmp near infi
# 关键字near表示目标位置仍在当前的代码段内。
```

## mov

```shell
mov 目的操作数，源操作数
# mov指令用于数据传送
# 目的操作数应该时一个容器，故：必须是通用寄存器或者内存单元
# 源操作数，可以是和目的操作数具有相同宽度的通用寄存器，内存单元还可以是立即数。
# 目的操作数 和 源操作数 不允许同时为内存单元

# 实例
mov byte [es:0x00],'L'
# 当前的mov指令是将立即数送到内存单元，目的操作数是内存单元，操作数是立即数。
# 为了访问内存单元，需要给出段地址和偏移地址。
# 一般情况下，如果没有任何附加提示，段地址默认在寄存器DS中。
# 当我们希望使用ES来访问内存时，使用段超越前缀“es:”，这说明我们明确要求处理器在生成物理地址时，使用段寄存器ES.
# 还要注意：目的数是一个内存地址，所以要用方括号括起来
# 最后，关键字 byte用来修饰目的操作数，指出本次传送是以字节的方式执行的。
```

## div 和 idiv

​	除法指令。它可以做两种类型的出发。

* 用16位的二进制数除以8位的二进制数。
  * 在这种情况下，被除数必须在寄存器AX中。必须事先传送到AX寄存器中。除数可以由8位的通用寄存器或者内存单元提供
  * 商放在AL中，余数挡在 AH中

* 用32位的二进制数除以16位的二进制数。
  * 在这种情况下，因为16位的处理器无法直接提供32位的被除数。故【被除数的高16位在DX中，低16位在AX中】
  * 商在AX中，余数在DX中

div ：无符号除法

idiv：有符号除法

## xor

* 异或。
* 指令的目的操作数可以是通用寄存器和内存单元。
* 源操作数：可以是通用寄存器、内存单元和立即数
* 不允许两个操作数同时位内存单元

```shell
0 xor 0 = 0
0 xor 1 = 1
1 xor 0 = 1
1 xor 1 = 0
```

## movsb和movsw

​	这两个指令通常用于把数据从内存的一个地方批量的传送（复制）到另一个地方。处理器把他们看成是数据串。

​	movsb的传送是以字节为单位，而movsw的传送是以字为单位。

```shell
# movsb 和movsw 指令执行时：
# 原始数据串的段地址由【DS】指定，偏移地址由【SI】指定，简写为【DS:SI】
# 目的地址由【ES:DI】指定
# 传输的字节数（movsb）或字数（movsw）由【CX】指定
# 还要指定正向传送还是反向传送。【正向传送】是：传送的方向是从内存区的低地址到高地址。【反向传送】则相反。
# 正向传送时，每传送一个字节或者字，SI和DI加1或加2
# 每传送一次，CX的内容自动减一。
```

​	movsb 和 movsw 没有操作数

​	单纯的movsb和movsw 只能执行一次。如果希望反复执行，则需要加上指令前缀：【rep】—意思是：CX不为0则重复。

## loop

循环指令：重复执行一段相同的代码。处理器执行它时，会做两件事情

```shell
# 将寄存器CX内容减一
# 如果CX内容不为0，则转移到指定的位置执行，否则顺序执行后面的指令

loop digit
# 在编译阶段，编译器用digit处的汇编地址减去loop指令的汇编地址，再减去loop指令的长度（2）得到的
```

## neg

​	该指令用来取一个操作数的负数。即用0减去指令中指定的操作数.

```SHELL
# neg 指令带一个操作数。可以是8位或16位的寄存器，也可以是内存单元
neg al
neg ax
neg word [lable_b]
```

## cbw和cbd

​	将一个8位的有符号数，用16位表示，只需要将最高位，扩展到高8位即可。

```shell
# cbw 没有操作数
# cbw 功能：将AL中的有符号数，扩展到AX

# cbd 也没有操作数
# cbd 功能：将AX中的有符号数，扩展到DX:AX
```

## 条件转移指令

| 指令 | 含义         | 反指令 | 含义         |
| ---- | ------------ | ------ | ------------ |
| js   | SF=1，则转移 | jns    | SF=0，则转移 |
| jz   | ZF=1，则转移 | jnz    | ZF=0，则转移 |
| jo   | OF=1，则转移 | jno    | OF=0，则转移 |
| jc   | CF=1，则转移 | jnc    | CF=0，则转移 |
| jp   | PF=1，则转移 | jnp    | PF=0，则转移 |

```shell
# 转移指令必须出现在影响标志的指令之后
dec si
jns show
```

## cmp

## jcxz (jump if cx is zero)

​	当CX寄存器为0时，转移。

​	jcxz show



​	